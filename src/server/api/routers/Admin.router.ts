// src/trpc/routers/admin.ts
// This file defines the tRPC procedures related to admin dashboard and services.

import { TRPCError } from '@trpc/server'
import bcrypt from 'bcryptjs'
import z from 'zod'

import { addNewService, createNewDoctor, createNewStaff } from '@/actions/admin'
import { deleteDataById } from '@/actions/general'
import authServer from '@/lib/auth'
import { generateId } from '@/lib/id'
import {
	CreateStaffOutputSchema,
	DoctorAuthSchema,
	ServicesSchema,
	StaffSchema,
	WorkingDaysSchema,
} from '@/lib/schema'
// Import your existing Prisma-based admin service functions
import { getAdminDashboardStats, getServices } from '@/server/services/admin' // Adjust path if different
import { generateRandomColor } from '@/utils'

import { adminProcedure, createTRPCRouter, protectedProcedure } from '../trpc'

// Import your tRPC setup (e.g., from src/trpc/init.ts)

export const adminRouter = createTRPCRouter({
	/**
	 * Fetches dashboard statistics for the admin panel.
	 * Requires authentication (admin role typically).
	 */
	getAdminDashboardStats: protectedProcedure.query(async () => {
		try {
			const result = await getAdminDashboardStats()
			return result
		} catch (error) {
			console.error('Error in tRPC adminRouter.getAdminDashboardStats:', error)
			if (error instanceof TRPCError) {
				throw error
			}
			throw new TRPCError({
				code: 'INTERNAL_SERVER_ERROR',
				message: 'Failed to fetch admin dashboard statistics.',
			})
		}
	}),

	/**
	 * Fetches a list of all services offered by the clinic.
	 * Can be public or protected depending on your app's requirements.
	 */
	getServices: protectedProcedure // Assuming services list is protected
		.query(async () => {
			try {
				const result = await getServices()
				return result
			} catch (error) {
				console.error('Error in tRPC adminRouter.getServices:', error)
				if (error instanceof TRPCError) {
					throw error
				}
				// Catch specific error message from service
				if (error instanceof Error && error.message.includes('Service data not found')) {
					throw new TRPCError({ code: 'NOT_FOUND', message: error.message })
				}
				throw new TRPCError({
					code: 'INTERNAL_SERVER_ERROR',
					message: 'Failed to fetch services.',
				})
			}
		}),
	createStaff: adminProcedure.input(StaffSchema).mutation(async ({ input }) => {
		return await createNewStaff(input) // âœ… input is type-checked
	}),

	createDoctor: adminProcedure
		.input(
			DoctorAuthSchema.extend({
				workSchedule: z.array(WorkingDaysSchema),
			}),
		)
		.mutation(async ({ input }) => {
			// Destructure workSchedule from input because createNewDoctor expects it separately
			const { workSchedule, ...doctorData } = input
			return await createNewDoctor({ ...doctorData, workSchedule })
		}),

	createNewStaff: adminProcedure
		// FIX: Input type is StaffSchema, the input 'data' is already validated by tRPC
		.input(StaffSchema) // Assuming StaffSchema is the correct input schema
		.output(CreateStaffOutputSchema)
		.mutation(async ({ input, ctx }) => {
			// 'input' is already the parsed data
			try {
				// No need for StaffSchema.safeParse(data) as 'input' is already parsed by tRPC
				// const result = StaffSchema.safeParse(data) // REMOVE THIS LINE
				// if (!result.success) { // REMOVE THIS BLOCK
				//     return { success: false, errors: true, message: 'Please provide all required info' }
				// }

				// Input is already validated against StaffSchema. We can directly use it.
				const { password, ...rest } = input // 'input' is our validated data

				if (!password) {
					// Ensure password exists, StaffSchema should make it required if needed
					throw new TRPCError({
						code: 'BAD_REQUEST',
						message: 'Password is required for new staff creation.',
					})
				}

				const hashedPassword = await bcrypt.hash(password, 10) // Hash the password

				const user = await authServer.createUser({
					// Use auth.api for user creation
					body: {
						email: rest.email,
						password: hashedPassword, // Use the hashed password
						name: rest.name,
						// FIX: Role should likely be 'staff' or a more generic 'user' role
						role: 'staff', // Adjust based on your User model's role enum
					},
				})

				// Check if user creation was successful
				if (!user || !user.user || !user.user.id) {
					throw new TRPCError({
						code: 'INTERNAL_SERVER_ERROR',
						message: 'Failed to create user account for staff.',
					})
				}

				await ctx.db.staff.create({
					// Use ctx.db
					data: {
						id: generateId(),
						...rest, // Spread other staff details from the validated input
						userId: user.user.id, // Connect staff to the newly created user
						// FIX: Don't override name with user.user.name unless intentional
						// If staff name is directly tied to user name:
						name: user.user.name,
						// FIX: id should typically be auto-generated by Prisma for staff,
						// unless your Staff model *is* the user model (which the 'user' relation implies it's not)
						// If Staff.id should *be* the User.id, then your Prisma schema
						// for Staff might need `@id @default(uuid()) @map("userId")` or similar for User.
						// Assuming Staff has its own UUID:
						// id: user.user.id, // REMOVE this line if Staff.id is separate UUID
						// KEEP this line if Staff.id IS the same as User.id (less common pattern)
						// If Staff.id is auto-generated UUID:
						// Prisma will automatically assign a new UUID if 'id' field is not provided
						// and is `String @id @default(uuid())` in schema.
						// So, remove `id: user.user.id` unless you explicitly want Staff.id to be same as User.id.
						colorCode: generateRandomColor(), // Ensure this function is imported
						status: 'ACTIVE', // Assuming this is a default status
					},
				})

				// FIX: Consistent return type as per CreateStaffOutputSchema
				return { success: true, msg: 'Staff added successfully!' }
			} catch (error) {
				console.error('Error creating staff:', error)

				// Handle specific auth client errors if available
				// Example: if (error.code === 'auth/email-already-in-use') { ... }

				if (error instanceof TRPCError) {
					throw error // Re-throw TRPCError
				}

				// Handle Prisma errors (e.g., unique constraint for email in User or Staff table)
				if (
					error instanceof Error &&
					'code' in error &&
					error.code === 'P2002' &&
					'meta' in error &&
					typeof error.meta === 'object' &&
					error.meta !== null &&
					'target' in error.meta &&
					Array.isArray(error.meta.target)
				) {
					const target = error.meta.target.join(', ')
					if (target.includes('email')) {
						// Check if the unique constraint violation is on email
						throw new TRPCError({
							code: 'CONFLICT',
							message: 'A staff member/user with this email already exists.',
						})
					}
				}

				// Generic error response
				throw new TRPCError({
					code: 'INTERNAL_SERVER_ERROR',
					message: 'Something went wrong while creating staff.',
					cause: error, // Pass the original error for debugging
				})
			}
		}),

	addService: adminProcedure.input(ServicesSchema).mutation(async ({ input }) => {
		return await addNewService(input)
	}),

	deleteDataById: protectedProcedure
		.input(
			z.object({
				id: z.string(),
				deleteType: z.enum(['doctor', 'staff', 'patient', 'payment', 'bill']),
			}),
		)
		.mutation(async ({ input }) => {
			return await deleteDataById(input.id, input.deleteType)
		}),
})
